/* ScummVM - Graphic Adventure Engine
*
* ScummVM is the legal property of its developers, whose names
* are too numerous to list here. Please refer to the COPYRIGHT
* file distributed with this source distribution.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>.
*
*/


#include "common/debug.h"
#include "common/endian.h"
#include "graphics/pixelformat.h"
#include "graphics/segagfx.h"
#include "snatcher/graphics.h"
#include "snatcher/palette.h"
#include "snatcher/render.h"
#include "snatcher/resource.h"
#include "snatcher/scroll.h"
#include "snatcher/util.h"

namespace Snatcher {

struct AnimObject {
	AnimObject() : enable(0), slowDown(0), drawFlags(0), posX(0), posY(0), speedXa(0), speedYa(0), f16(0), f18(0), f1c(0), timeStamp(0), f24(0), controlFlags(0), allowFrameDrop(0), frameSeqCounter(0), frame(0), frameDelay(0), f2c(0), f2d(0), spriteTableLocation(0), res(), scriptData(), spriteData(0), speedX(0), speedY(0), parent(0), children(0), next(0), f4e(0), f4f(0) {}

	void clear() {
		*this = Common::move(AnimObject());
		/*enable = 0;
		delay = 0;
		drawFlags = 0;
		posX = 0;
		posY = 0;
		fe = 0;
		f10 = 0;
		f11 = 0;
		f12 = 0;
		f13 = 0;
		f14 = 0;
		f15 = 0;
		f16 = 0;
		f18 = 0;
		f1c = 0;
		f20 = 0;
		f21 = 0;
		f22 = 0;
		f23 = 0;
		f24 = 0;
		controlFlags = 0;
		f26 = 0;
		f27 = 0;
		frame = 0;
		f2a = 0;
		f2c = 0;
		f2d = 0;
		offs_2e = 0;
		res = ResourcePointer();
		animData = 0;
		spriteData = 0;
		speedX = 0;
		speedY = 0;
		prev = 0;
		next = 0;
		next2 = 0;
		f4e = 0;
		f4f = 0;*/
	}

	uint16 enable;
	uint16 slowDown;
	uint16 drawFlags;
	uint32 posX;
	uint32 posY;

	uint32 speedXa;
	uint32 speedYa;
	uint8 f16;
	uint16 f18;
	uint8 f1c;
	uint8 timeStamp;
	uint8 f24;
	uint8 controlFlags;
	uint8 allowFrameDrop;
	uint8 frameSeqCounter;
	uint16 frame;
	int16 frameDelay;
	uint8 f2c;
	uint8 f2d;

	uint32 spriteTableLocation;
	ResourcePointer res;
	ResourcePointer scriptData;
	const uint16 *spriteData;

	uint32 speedX;
	uint32 speedY;
	uint16 parent;
	uint16 children;
	uint16 next;
	uint8 f4e;
	uint8 f4f;
};

class GraphicsEngine;
class Renderer_SCD : public Renderer, public Graphics::SegaRenderer::HINTClient {
public:
	Renderer_SCD(const Graphics::PixelFormat *pxf, GraphicsEngine::GfxState &state, Palette *pal, ScrollManager *scr);
	~Renderer_SCD() override;

	bool enqueueCopyCommands(ResourcePointer &res) override;
	void clearCopyCommands() override;
	void initData(ResourcePointer &res, uint8 mode) override;
	void initAnimations(ResourcePointer &res, uint16 len) override;
	void linkAnimations(ResourcePointer &res, uint16 len) override;
	void clearAnimations(int mode = 0) override;
	void setPlaneMode(uint16 mode) override;

	void updateScreen(uint8 *screen) override;
	void updateAnimations() override;

	void anim_setControlFlags(uint8 animObjId, int flags) override;
	void anim_clearControlFlags(uint8 animObjId, int flags) override;
	void anim_setFrame(uint8 animObjId, uint16 frameNo) override;
	uint16 anim_getCurFrameNo(uint8 animObjId) const override;
	bool anim_isEnabled(uint8 animObjId) const override;

	uint16 screenWidth() const override { return _screenWidth; }
	uint16 screenHeight() const override { return _screenHeight; }

	void hINTCallback(Graphics::SegaRenderer *sr) override;

private:
	void loadDataFromGfxScript();
	void executeCopyCommands();
	void drawSprites();
	void reconfigPlanes();
	void updateScrollState();

	void drawSprite(AnimObject &a);
	void updateAnim32Spec(AnimObject &a);
	bool reachedAudioTimeStamp(AnimObject &a) const;
	void runAnimScript(AnimObject &a);

	const uint16 _screenWidth, _screenHeight;

	ResourcePointer _transferData;
	uint8 *_tempBuffer;
	uint16 *_spriteBuffer;
	uint8 _transferMode;
	uint16 _transferDelay;
	uint16 _clearFlags;
	uint8 _mode;
	uint8 _modeChange;
	Graphics::SegaRenderer *_sr;
	Palette *_pal;
	ScrollManager *_scroll;
	const Graphics::SegaRenderer::HINTHandler _hINTClientProc;

private:
	AnimObject *_animations;

	struct CopyCommand {
		CopyCommand() : cmd(0), progress(0), ptr(0), res(), c(0), d(0) {}
		void clear() {
			cmd = 0;
			progress = 0;
			ptr = 0;
			res = ResourcePointer();
			c = 0;
			d = 0;
		}
		uint8 cmd;
		uint8 progress;
		const uint8 *ptr;
		ResourcePointer res;
		uint8 c;
		uint8 d;
	};

	CopyCommand *_copyCommands;

private:
	typedef Common::Functor2Mem<AnimObject&, const uint8*, int, Renderer_SCD> GfxAnimFunc;
	Common::Array<GfxAnimFunc*> _animProcs;

	void makeAnimFunctions();

	int anim_remove(AnimObject &a, const uint8 *data);
	int anim_setFrame(AnimObject &a, const uint8 *data);
	int anim_seqSetFrame(AnimObject &a, const uint8 *data);
	int anim_rndSeqSetFrame(AnimObject &a, const uint8 *data);
	int anim_setX(AnimObject &a, const uint8 *data);
	int anim_setY(AnimObject &a, const uint8 *data);
	int anim_06(AnimObject &a, const uint8 *data);
	int anim_07(AnimObject &a, const uint8 *data);
	int anim_palEvent(AnimObject &a, const uint8 *data);
	int anim_palReset(AnimObject &a, const uint8 *data);
	int anim_copyCmds(AnimObject &a, const uint8 *data);
	int anim_11(AnimObject &a, const uint8 *data);
	int anim_12(AnimObject &a, const uint8 *data);
	int anim_13(AnimObject &a, const uint8 *data);
	int anim_14(AnimObject &a, const uint8 *data);
	int anim_15(AnimObject &a, const uint8 *data);
	int anim_pause(AnimObject &a, const uint8 *data);
	int anim_resumeAndUnsyncOther(AnimObject &a, const uint8 *data);
	int anim_removeOther(AnimObject &a, const uint8 *data);
	int anim_pauseAndHideOther(AnimObject &a, const uint8 *data);
	int anim_hide(AnimObject &a, const uint8 *data);
	int anim_24(AnimObject &a, const uint8 *data);
	int anim_audioSync(AnimObject &a, const uint8 *data);
	int anim_27(AnimObject &a, const uint8 *data);
	int anim_28(AnimObject &a, const uint8 *data);
	int anim_29(AnimObject &a, const uint8 *data);
	int anim_30(AnimObject &a, const uint8 *data);
	int anim_31(AnimObject &a, const uint8 *data);
	int anim_setDrawFlags(AnimObject &a, const uint8 *data);
	int anim_34(AnimObject &a, const uint8 *data);
	int anim_35(AnimObject &a, const uint8 *data);
	int anim_36(AnimObject &a, const uint8 *data);
	int anim_37(AnimObject &a, const uint8 *data);
	int anim_38(AnimObject &a, const uint8 *data);
	int anim_39(AnimObject &a, const uint8 *data);
	int anim_40(AnimObject &a, const uint8 *data);
	int anim_41(AnimObject &a, const uint8 *data);
	int anim_42(AnimObject &a, const uint8 *data);
	int anim_43(AnimObject &a, const uint8 *data);
	int anim_allowFrameDrop(AnimObject &a, const uint8 *data);
	int anim_45(AnimObject &a, const uint8 *data);
	int anim_46(AnimObject &a, const uint8 *data);
	int anim_47(AnimObject &a, const uint8 *data);

	int anim_updateFrameDelay(AnimObject &a, const uint8 *data);
	void anim_setGroupParameter(AnimObject &a, int pata, uint16 val = 0, bool recursive = false);
};

Renderer_SCD::Renderer_SCD(const Graphics::PixelFormat *pxf, GraphicsEngine::GfxState &state, Palette *pal, ScrollManager *scr) : Renderer(state), _pal(pal), _scroll(scr), _mode(1),
	_modeChange(0), _screenWidth(256), _screenHeight(224), _transferData(), _transferMode(0), _transferDelay(0), _clearFlags(0), _tempBuffer(nullptr), _spriteBuffer(nullptr), _sr(nullptr),
		_animations(nullptr), _copyCommands(nullptr), _hINTClientProc(Graphics::SegaRenderer::HINTHandler(this, &Graphics::SegaRenderer::HINTClient::hINTCallback)) {

	makeAnimFunctions();

	assert(pxf);
	_sr = new Graphics::SegaRenderer(pxf);
	assert(_sr);

	_tempBuffer = new uint8[0x10000]();
	assert(_tempBuffer);

	_spriteBuffer = new uint16[0x100]();
	assert(_spriteBuffer);

	_animations = new AnimObject[64];
	assert(_animations);

	_copyCommands = new CopyCommand[7];
	assert(_copyCommands);

	_sr->setResolution(_screenWidth, _screenHeight);
	_sr->setupWindowPlane(0, 0, Graphics::SegaRenderer::kWinToLeft, Graphics::SegaRenderer::kWinToTop);
	_sr->setVScrollMode(Graphics::SegaRenderer::kVScrollFullScreen);
	_sr->setHScrollMode(Graphics::SegaRenderer::kHScrollFullScreen);
	_sr->hINT_setHandler(&_hINTClientProc);

	reconfigPlanes();
}

Renderer_SCD::~Renderer_SCD() {
	delete _sr;
	delete[] _tempBuffer;
	delete[] _spriteBuffer;
	delete[] _animations;
	delete[] _copyCommands;

	for (uint i = 0; i < _animProcs.size(); ++i) \
		delete _animProcs[i];
}

bool Renderer_SCD::enqueueCopyCommands(ResourcePointer &res) {
	for (CopyCommand *it = _copyCommands; it < &_copyCommands[7]; ++it) {
		if (it->cmd != 0)
			continue;
		it->res = res;
		it->cmd = *res++;
		it->progress = 0;
		it->ptr = ++res;
		return true;
	}
	return false;
}

void Renderer_SCD::clearCopyCommands() {
	for (CopyCommand *it = _copyCommands; it < &_copyCommands[7]; ++it)
		it->clear();
}

void Renderer_SCD::initData(ResourcePointer &res, uint8 mode) {
	_transferData = res;
	_transferMode = mode;
}

void Renderer_SCD::initAnimations(ResourcePointer &res, uint16 len) {
	ResourcePointer next = res + len;
	ResourcePointer in = res;
	while (in < next) {
		assert(in[0] < 64);
		AnimObject *a = &_animations[*in++];
		if (a->enable)
			return;

		a->clear();
		a->enable = 1;
		a->res = res;
		a->controlFlags = *in++;
		a->posX = in.readIncrSINT16() << 16;
		a->posY = in.readIncrSINT16() << 16;
		a->spriteTableLocation = in.readIncrUINT32();
		int16 offs = in.readIncrSINT16();
		a->scriptData = in + offs;
		a->frame = 0xFFFF;

		uint8 cmd = a->scriptData[0];
		for (bool l = true; l; ) {
			if (cmd == 0xA1 || cmd == 0xA7) {
				a->f16 = a->scriptData[1];
				cmd = a->scriptData[4];
				assert(cmd != 0xA1 && cmd != 0xA7); // The original code would theoretically allow a deadlock here.
			} else {
				if (!(cmd & 0x80))
					a->spriteData = reinterpret_cast<const uint16*>(res.makeAbsPtr(a->spriteTableLocation).getDataFromTable(cmd)());
				l = false;
			}
		}
	}
}

void Renderer_SCD::linkAnimations(ResourcePointer &res, uint16 len) {
	ResourcePointer next = res + len;
	ResourcePointer in = res;
	while (in < next) {
		uint16 p = *in++;
		uint16 c = *in++;
		assert(p < 64 && c < 64);
		AnimObject *pPr = &_animations[p];
		AnimObject *pCh = &_animations[c];
		pCh->next = pPr->children;
		pPr->children = c;
		pCh->parent = p;
	}
}

void Renderer_SCD::clearAnimations(int mode) {
	if (mode) {
		for (int i = 1; i < 64; ++i) {
			AnimObject *s = &_animations[i];
			if (s->enable && !(s->f4e & 1))
				s->clear();
		}
	} else {
		for (int i = 1; i < 64; ++i)
			_animations[i].clear();
	}
}
void Renderer_SCD::setPlaneMode(uint16 mode) {
	assert(mode >> 8 == 0);
	_modeChange = mode & 0xFF;;
}

void Renderer_SCD::updateScreen(uint8 *screen) {
	if (_gfxState.getVar(9)) {
		_sr->setPlaneTableLocation(Graphics::SegaRenderer::kPlaneB, _gfxState.getVar(9) == 0xFF ? 0xE000 : 0xC000);
		_gfxState.setVar(9, 0);
	}

	if (_clearFlags & 1)
		_sr->memsetVRAM(0xE000, 0, 0x2000);
	if (_clearFlags & 2)
		_sr->memsetVRAM(0xC000, 0, 0x2000);
	_clearFlags = 0;

	if (_modeChange)
		reconfigPlanes();

	loadDataFromGfxScript();
	executeCopyCommands();
	drawSprites();
	updateScrollState();

	_sr->setRenderColorTable(_pal->getSystemPalette(), 0, 64);
	_sr->render(screen);
}

void Renderer_SCD::updateAnimations() {
	for (AnimObject *s = _animations; s < &_animations[64]; ++s) {
		int16 dropFrames = _gfxState.getDropFrames();
		if ((s->f1c || s->allowFrameDrop) && _gfxState.getVar(10))
			continue;
		if (dropFrames)
			debug("%s(): Dropping %d frames for anim %d", __FUNCTION__, dropFrames, s - _animations);
		do {
			if (!s->enable)
				break;
			if (s->controlFlags & GraphicsEngine::kAnimAudioSync) {
				if (!reachedAudioTimeStamp(*s))
					break;
				s->controlFlags &= ~GraphicsEngine::kAnimAudioSync;
			}
			if (s->controlFlags & GraphicsEngine::kAnimPause)
				break;

			runAnimScript(*s);

		} while (--dropFrames >= 0 && s->allowFrameDrop);
	}

	for (AnimObject *s = _animations; s < &_animations[64]; ++s) {
		if (!s->enable || (s->f1c & _gfxState.getVar(10)))
			continue;

		uint8 cmd = s->scriptData[(s->frame == 0xFFFF ? 0 : s->frame) << 2];
		if (!(cmd & 0x80))
			s->spriteData = reinterpret_cast<const uint16*>(s->res.makeAbsPtr(s->spriteTableLocation).getDataFromTable(cmd)());

		if (!(s->controlFlags & GraphicsEngine::kAnimPause)) {
			s->posX += s->speedX;
			s->posY += s->speedY;
		}
	}
}

void Renderer_SCD::anim_setControlFlags(uint8 animObjId, int flags) {
	assert(animObjId < 64);
	flags &= 7;
	_animations[animObjId].controlFlags |= flags;
}

void Renderer_SCD::anim_clearControlFlags(uint8 animObjId, int flags) {
	assert(animObjId < 64);
	_animations[animObjId].controlFlags &= ~flags;
}

void Renderer_SCD::anim_setFrame(uint8 animObjId, uint16 frameNo) {
	assert(animObjId < 64);
	_animations[animObjId].frame = frameNo;
}

uint16 Renderer_SCD::anim_getCurFrameNo(uint8 animObjId) const {
	assert(animObjId < 64);
	return _animations[animObjId].frame;
}

bool Renderer_SCD::anim_isEnabled(uint8 animObjId) const {
	assert(animObjId < 64);
	return _animations[animObjId].enable != 0;
}

void Renderer_SCD::hINTCallback(Graphics::SegaRenderer *sr) {
	if (_pal)
		_pal->hINTCallback(sr);
	if (_scroll)
		_scroll->hINTCallback(sr);
}

void Renderer_SCD::loadDataFromGfxScript() {
	if (_gfxState.getVar(0)) {
		if (_gfxState.getVar(0) == 1) {
			_gfxState.setVar(0, 2);
			_clearFlags = 3;
		} else {
			_gfxState.setVar(0, 0);
		}
		return;
	}

	if (!_gfxState.getVar(8))
		return;
	
	if (_transferDelay) {
		--_transferDelay;
		return;
	}

	if (_transferData.readUINT16() == 0xFFFF) {
		_gfxState.setVar(8, 0);
		return;
	}

	const byte *src = _transferData.makeAbsPtr(_transferData.readIncrUINT32() & 0xFFFFFF)();
	_transferDelay = _transferData.readIncrUINT16();
	uint16 addr = _transferData.readIncrUINT16();

	if (!_transferMode) {
		uint32 len = READ_BE_UINT16(src);
		if (len != Util::decodeSCDData(src + 2, _tempBuffer))
			error("%s(): Decode size mismatch", __FUNCTION__);
		_sr->loadToVRAM(_tempBuffer, len, addr);
		return;
	}

	assert(0);

	// multi part transfer: not needed (this is just due to original hardware limitations with the word ram and dma transfer)

	/*int D7 = 0;
	if (_transferOffset) {
		D7 = 0;//processGfxScriptCase1_set_dstA5_to_238000_etc();
		//len = D7;
	}*/

	//_transferSrc = 0x238000;
	//_transferVRAMAddr += _transferOffset;
	//_transferSrc += _transferOffset;

	//if (_transferLen >= 0x800) {
	//	_transferLen -= 0x800;
	//	_transferOffset += 0x800;
	//	D7 = 0x800;
	/*} else {
		D7 = _transferLen;
		_transferOffset = 0;
		_transferCommands += 8;
	}*/
	// code = 2
	// ga_comm_loc_E322_writeWordRam_codeD6_dstA5_srcA6_lenD7
}

void Renderer_SCD::executeCopyCommands() {
	if (_gfxState.getVar(8))
		return;

	static const uint8 offs[] =	{ 0x02, 0x03, 0x01, 0x03, 0x00, 0x02, 0x00, 0x01 };
	static const uint8 mask[] =	{ 0xF0, 0x0F, 0xF0, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F };

	for (CopyCommand *it = _copyCommands; it < &_copyCommands[7]; ++it) {
		if (it->cmd == 0)
			continue;

		bool loop = (it->cmd & 0x40);
		int section = (it->cmd & 0x30) >> 4;
		uint8 *s = _tempBuffer + section * 0x2000;
		const uint8 *bptr = nullptr;
		uint8 a = 0;
		uint8 b = 0;

		if ((it->cmd & 0x0F) < 4 && (it->cmd & 0x0F) != 1 && !(it->cmd & 0x80)) {
			const uint8 *cmp = it->res.makeAbsPtr(READ_BE_UINT32(it->ptr))();
			uint32 len = READ_BE_UINT16(cmp);
			if (len != Util::decodeSCDData(cmp + 2, s))
				error("%s(): Decode size mismatch", __FUNCTION__);
		}

		switch (it->cmd & 0x0F) {
		case 0:
			_sr->loadToVRAM(s + READ_BE_INT16(it->ptr + 6), READ_BE_UINT16(it->ptr + 8), READ_BE_UINT16(it->ptr + 4));
			it->ptr += 10;
			if (READ_BE_UINT16(it->ptr) == 0xFFFF) {
				it->cmd = 0;
				break;
			}
			break;
		case 1:
			for (bool rept = true; rept; ) {
				memcpy(s + READ_BE_INT16(it->ptr + 6), it->res.makeAbsPtr(READ_BE_UINT32(it->ptr))(), READ_BE_UINT16(it->ptr + 8));
				_sr->loadToVRAM(s + READ_BE_INT16(it->ptr + 6), READ_BE_UINT16(it->ptr + 8), READ_BE_UINT16(it->ptr + 4));
				it->ptr += 10;
				if (READ_BE_UINT16(it->ptr) == 0xFFFF) {
					it->cmd = 0;
					rept = false;
				}
			}
			break;
		case 2:
			it->cmd |= 0x80;
			for (bool rept = true; rept; ) {
				_sr->loadToVRAM(s + READ_BE_INT16(it->ptr + 6), READ_BE_UINT16(it->ptr + 8), READ_BE_UINT16(it->ptr + 4));
				if (bptr)
					it->ptr = bptr;
				it->ptr += 10;
				if (READ_BE_UINT16(it->ptr) == 0xFFFF) {
					it->cmd = 0;
					rept = false;
				}
				bptr = it->ptr - 4;
				it->ptr = it->res.makeAbsPtr(READ_BE_UINT32(bptr))();
			}
			break;
		case 3:
			it->cmd |= 0x80;
			a = it->progress & 7;
			b = (a + (((it->progress >> 3) * 5) & 7)) & 7;
			a = (a << 2) + offs[b];
			s += (a + READ_BE_INT16(it->ptr + 6));
			b = mask[b];
			a = READ_BE_UINT16(it->ptr + 8) >> 5;
			while (a--) {
				*s &= b;
				s += 32;
			}
			s = _tempBuffer + section * 0x2000;
			_sr->loadToVRAM(s + READ_BE_INT16(it->ptr + 6), READ_BE_UINT16(it->ptr + 8), READ_BE_UINT16(it->ptr + 4));
			if (++it->progress == 65)
				it->cmd = 0;
			break;
		case 4:
			if (it->progress == 0)
				memset(s, 0, 32);
			a = it->progress & 7;
			b = (a + (((it->progress >> 3) * 5) & 7)) & 7;
			a = (a << 2) + offs[b];
			b = (mask[b] ^ 0xFF) & 0x77;
			s[a] |= b;
			_sr->loadToVRAM(s, 32, 0);
			if (++it->progress == 65)
				it->cmd = 0;
			break;
		default:
			error("%s(): Invalid instruction", __FUNCTION__);
			break;
		}

		if (!loop)
			break;
	}
}

void Renderer_SCD::drawSprites() {
	for (int i = 63; i >= 0; --i) {
		AnimObject &a = _animations[i];
		if (a.enable && a.spriteData != nullptr && !(a.controlFlags & GraphicsEngine::kAnimHide) && a.slowDown != 0xFFFF && !(a.slowDown & _gfxState.frameCount()))
			drawSprite(a);
		if (i == 32)
			updateAnim32Spec(a);
	}
}

static const uint8 src0000[] = {
	0x13, 0x00, 0xaa, 0x00, 0x1c, 0x01, 0x11, 0x1c,
	0x01, 0x22, 0x04, 0x01, 0x33, 0x04, 0x01, 0xaa,
	0x44, 0x91, 0x55, 0x91, 0x77, 0x91, 0x99, 0x91,
	0xbf, 0xa8, 0x01, 0x10, 0x01, 0x18, 0xa1, 0x01,
	0x28, 0x01, 0x30, 0xff, 0x04, 0x01, 0x95, 0x06,
	0x69, 0x05, 0x01, 0x6e, 0x70, 0x99, 0x09, 0x00,
	0x00, 0x3f, 0x3b, 0xd3, 0xa7, 0x77, 0x78, 0x89,
	0xab, 0x99, 0xaa, 0xac, 0xcc, 0x78, 0x9a, 0xbc,
	0xcc, 0x56, 0x7a, 0xbb, 0xcc, 0x05, 0x56, 0x5a,
	0xaa, 0x00, 0x00, 0x85, 0x77, 0x00, 0x07, 0x00,
	0x27, 0x50, 0x15, 0xae, 0xc8, 0x05, 0x50, 0x50,
	0x05, 0x87, 0x00, 0x57, 0x79, 0x90, 0x00, 0xaa,
	0xba, 0x00, 0x00, 0xcc, 0xb7, 0x94, 0xa5, 0x50,
	0x95, 0x84, 0xa7, 0x88, 0xab, 0x9c, 0x57, 0xa9,
	0x00, 0x3b, 0xb4, 0x08, 0x80, 0x00, 0x68, 0x75,
	0x05, 0x71, 0x0a, 0x3d, 0x55, 0x00, 0x23, 0xab,
	0xd3, 0x77, 0x55, 0x05, 0x7a, 0x67, 0x79, 0x87,
	0xac, 0x77, 0x8a, 0xbc, 0xcc, 0x98, 0x9a, 0xab,
	0xcc, 0x77, 0x77, 0x7a, 0xcc, 0x56, 0x66, 0x57,
	0xcc, 0x05, 0x55, 0x55, 0x00, 0x52, 0x59, 0x00,
	0x4a, 0x58, 0x00, 0x7e, 0x77, 0x00, 0x85, 0x4f,
	0x00, 0x2e, 0x01, 0xb3, 0xa7, 0x9f, 0x05, 0x85,
	0x87, 0x7a, 0x96, 0x95, 0x00, 0x68, 0x00, 0x1e,
	0xcc, 0x00, 0x5f, 0xcc, 0xa7, 0x00, 0x78, 0x42,
	0xca, 0x89, 0xcc, 0xcb, 0xa5, 0x00, 0x87, 0x98,
	0xf2, 0x75, 0x8f, 0x55, 0x75, 0x01, 0x76, 0x16,
	0xbb, 0x27, 0x06, 0xcd, 0x57, 0x55, 0x56, 0x66,
	0x7a, 0x77, 0x77, 0x89, 0xac, 0xaa, 0xab, 0xbc,
	0xcc, 0x77, 0x78, 0xbb, 0xcc, 0x55, 0x56, 0x67,
	0xac, 0xb5, 0x00, 0x9e, 0x7b, 0x00, 0x1c, 0x5a,
	0x22, 0x21, 0x84, 0x08, 0x94, 0x5d, 0x21, 0x0a,
	0x05, 0x21, 0x0b, 0x21, 0x36, 0x01, 0xd6, 0x90,
	0x94, 0xa5, 0x1d, 0x94, 0xb7, 0x00, 0x84, 0x00,
	0x7b, 0x03, 0x84, 0xba, 0x98, 0x75, 0x7f, 0xac,
	0x9b, 0x02, 0xf6, 0x2f, 0x3b, 0x04, 0xc1, 0x02,
	0xd8, 0x01, 0xe0, 0x05, 0x20, 0xba, 0x56, 0x66,
	0x8a, 0xcc, 0x00, 0x7f, 0xcc, 0x99, 0x04, 0x9a,
	0xcc, 0x98, 0xbc, 0xcc, 0x55, 0x68, 0x99, 0xfa,
	0xac, 0x20, 0x95, 0x7a, 0x01, 0x9c, 0x31, 0x39,
	0x01, 0x46, 0x01, 0x88, 0x01, 0x60, 0xc7, 0x01,
	0xe8, 0x01, 0xf0, 0x01, 0xf8, 0xcc, 0xca, 0x70,
	0x03, 0x84, 0x00, 0x80, 0x0f, 0x21, 0x18, 0x21,
	0x20, 0x21, 0x28, 0x29, 0x3f, 0x00, 0x45, 0x33,
	0x22, 0x69, 0x84, 0x55, 0x33, 0x94, 0x55, 0x21,
	0xf9, 0xa4, 0x04, 0xdd, 0x03, 0x04, 0x5e, 0xa4,
	0x45, 0x5c, 0x41, 0x34, 0xee, 0x04, 0x01, 0x41,
	0x38, 0x2b, 0x05, 0x0c, 0x04, 0x20, 0x32, 0x03,
	0x20, 0xe2, 0xb4, 0xff, 0xff, 0x8e, 0xf2, 0x9c,
	0x01, 0x10, 0x40, 0x9e, 0x20, 0x00, 0x00, 0xb4,
	0x76, 0x30, 0x04, 0x04, 0x00, 0x73, 0x23, 0x04,
	0x04, 0x00, 0x1b, 0x1d, 0x01, 0x04, 0x55, 0x20,
	0xf8, 0x5e, 0x94, 0x5d, 0x00, 0x9f, 0xee, 0x94,
	0xdd, 0x7b, 0xa4, 0x00, 0x97, 0xee, 0x00, 0x13,
	0x98, 0x84, 0x01, 0x84, 0xdd, 0x67, 0x91, 0x05,
	0x08, 0x0f, 0x0c, 0x22, 0x22, 0x8c, 0x00, 0x8c,
	0xe2, 0xb1, 0x98, 0xd2, 0x22, 0x23, 0xa4, 0x00,
	0x97, 0x20, 0x00, 0x13, 0xf6, 0x30, 0xa4, 0x00,
	0x93, 0x00, 0xa4, 0x19, 0x84, 0x44, 0x18, 0xa4,
	0x36, 0x45, 0x24, 0xb1, 0x40, 0x76, 0x04, 0x94,
	0x00, 0x9a, 0x55, 0xdd, 0xe9, 0x00, 0x90, 0xcc,
	0xcc, 0xb8, 0x5c, 0x98, 0xa4, 0x00, 0x7d, 0xf5,
	0x00, 0x13, 0xcc, 0x9b, 0xcc, 0x01, 0x88, 0x97,
	0x06, 0x08, 0x15, 0x0c, 0x75, 0x0c, 0x20, 0xd2,
	0x9c, 0xc2, 0x00, 0x43, 0xc1, 0x22, 0xd2, 0x22,
	0x22, 0x00, 0xc2, 0x22, 0x23, 0x00, 0x88, 0x20,
	0x7e, 0x00, 0x00, 0xaf, 0x94, 0x20, 0x48, 0x20,
	0x41, 0x25, 0x54, 0x63, 0x37, 0x45, 0x63, 0x94,
	0x20, 0xc0, 0x04, 0x55, 0x5b, 0x00, 0x93, 0x84,
	0x45, 0x54, 0x55, 0xcc, 0x40, 0x30, 0xbb, 0x9f,
	0xbb, 0x01, 0x84, 0xbb, 0x5f, 0x91, 0x01, 0x5c,
	0xa8, 0x15, 0x0c, 0x18, 0x20, 0x22, 0x8c, 0xb2,
	0xf6, 0x22, 0x00, 0x8f, 0x98, 0x22, 0xb4, 0x9b,
	0x8c, 0x20, 0x3c, 0x3e, 0xb2, 0x00, 0x89, 0x25,
	0xd0, 0x21, 0xcc, 0x3c, 0x48, 0x2d, 0xdb, 0x55,
	0x04, 0x3f, 0x41, 0x74, 0x27, 0x64, 0x20, 0x5c,
	0x00, 0xc8, 0x20, 0xe5, 0x93, 0xbb, 0x55, 0xc8,
	0x55, 0xaa, 0xaa, 0x93, 0xaa, 0x45, 0x8b, 0x8c,
	0xfe, 0x5a, 0x9c, 0x00, 0x91, 0x97, 0xb1, 0x01,
	0x9c, 0x04, 0x0b, 0x06, 0x0c, 0xbb, 0x11, 0x14,
	0x1c, 0x20, 0x33, 0x82, 0x81, 0x04, 0x0c, 0xa2,
	0x00, 0x5f, 0x06, 0x22, 0x97, 0x84, 0xa3, 0x23,
	0x23, 0xb3, 0x33, 0xc4, 0x33, 0x30, 0x40, 0xf3,
	0x00, 0x33, 0x44, 0x20, 0x6c, 0x21, 0x74, 0x9f,
	0x21, 0x70, 0x40, 0xc0, 0x41, 0xb8, 0x5c, 0x2c,
	0x00, 0x32, 0x44, 0x55, 0x93, 0x2a, 0x55, 0x93,
	0x59, 0x93, 0x99, 0x05, 0x18, 0x04, 0x44, 0xd6,
	0x44, 0x01, 0xd8, 0xa1, 0x99, 0x01, 0xd8, 0x99,
	0x04, 0x01, 0x01, 0x30, 0xbf, 0x00, 0x1b, 0x05,
	0x01, 0x02, 0x17, 0x01, 0xa8, 0x05, 0x20, 0x03,
	0x18, 0x59, 0x0a, 0x34, 0x0f, 0x09, 0x20, 0x05,
	0x0c, 0x11, 0x14, 0x14, 0x20, 0x44, 0xaa, 0xaa,
	0x44, 0x26, 0x44, 0x86, 0x61, 0xd6, 0x33, 0x00,
	0x04, 0x18, 0x44, 0xaa, 0xf4, 0xa4, 0x44, 0x05,
	0x01, 0x40, 0x82, 0x07, 0xd1, 0x00, 0x2b, 0x08,
	0x01, 0x7f, 0x10, 0xf1, 0x05, 0x34, 0x37, 0x11,
	0x5d, 0x09, 0x20, 0xf8, 0x61, 0x4c, 0x20, 0xfc,
	0x04, 0x91, 0x40, 0xc4, 0x45, 0x55, 0x58, 0x97,
	0x99, 0x05, 0x87, 0x52, 0x88, 0x8b, 0x88, 0x88,
	0x00, 0xfb, 0x99, 0x97, 0x88, 0xfd, 0x97, 0x99,
	0x97, 0xb1, 0x21, 0x18, 0x0d, 0x0c, 0x11, 0x14,
	0x04, 0x0c, 0x4a, 0x94, 0x00, 0x3f, 0x33, 0x87,
	0x93, 0x32, 0x87, 0x32, 0x40, 0x23, 0x88, 0x82,
	0x22, 0x30, 0x99, 0x60, 0x45, 0x88, 0x03, 0x40,
	0xbc, 0x8b, 0x20, 0x00, 0x43, 0x33, 0x00, 0x00,
	0xd7, 0x93, 0x39, 0xd8, 0x41, 0x9c, 0x05, 0x03,
	0xa8, 0x00, 0x40, 0xb0, 0x01, 0xac, 0x45, 0x67,
	0x74, 0x55, 0x01, 0xa4, 0x57, 0x77, 0x77, 0x00,
	0xaf, 0x88, 0xde, 0x55, 0x87, 0x88, 0x94, 0x9b,
	0x88, 0x00, 0x13, 0xb1, 0x6f, 0x01, 0x88, 0x09,
	0x08, 0x15, 0x0c, 0x04, 0x20, 0x72, 0xa4, 0x00,
	0xb0, 0x22, 0xf3, 0x00, 0x4b, 0x94, 0x72, 0x22,
	0x00, 0xaf, 0x40, 0x84, 0x40, 0x80, 0x41, 0x84,
	0x1f, 0x60, 0x65, 0x41, 0x88, 0xb4, 0x64, 0x78,
	0x22, 0x34, 0x05, 0x55, 0x56, 0x55, 0x20, 0x38,
	0x57, 0x00, 0x8f, 0x56, 0x20, 0x3c, 0x66, 0x8f,
	0x55, 0x52, 0x77, 0x94, 0x66, 0x45, 0x8f, 0x66,
	0x01, 0x74, 0x66, 0xa7, 0x91, 0x05, 0x08, 0x0f,
	0x0c, 0x72, 0x22, 0x8c, 0x22, 0x00, 0x6c, 0xd3,
	0x84, 0xa8, 0x66, 0x62, 0x9c, 0x72, 0x03, 0x08,
	0x9f, 0x7e, 0x23, 0x65, 0xdc, 0xa4, 0x21, 0x24,
	0x3e, 0x28, 0x2a, 0x2c, 0x21, 0x21, 0x56, 0xea,
	0x66, 0x03, 0x04, 0x66, 0x0b, 0x04, 0x56, 0x03,
	0x04, 0x1e, 0x01, 0x00, 0x84, 0xeb, 0xa4, 0x00,
	0x8f, 0x20, 0x04, 0x04, 0x30, 0xa4, 0x8b, 0xb4,
	0xf3, 0x22, 0x01, 0x23, 0x90, 0x05, 0x54, 0x9c,
	0x01, 0x78, 0x0a, 0xa1, 0x01, 0x68, 0xfe, 0x54,
	0x40, 0xc4, 0x64, 0x7c, 0x01, 0x94, 0x0a, 0x20,
	0x01, 0x63, 0x41, 0xe3, 0x65, 0x82, 0xcb, 0x0d,
	0xde, 0x01, 0x64, 0x55, 0x20, 0x7d, 0x55, 0x55,
	0xa4, 0x0e, 0x1f, 0x08, 0x00, 0x20, 0x02, 0x00,
	0x99, 0x24, 0x33, 0x33, 0x20, 0x10, 0x5e, 0xee,
	0xee, 0x02, 0xa4, 0x5d, 0xdd, 0xdd, 0x62, 0x05,
	0x83, 0xdd, 0x25, 0xcc, 0x81, 0x94, 0xc3, 0xd5,
	0x21, 0xb4, 0x33, 0x94, 0xe3, 0x04, 0x04, 0x32,
	0x20, 0x3f, 0x05, 0x04, 0xa7, 0x21, 0x54, 0x40,
	0x94, 0x84, 0x83, 0x20, 0xb4, 0x77, 0x00, 0x1d,
	0xed, 0x05, 0x04, 0x63, 0x00, 0x30, 0xa4, 0x00,
	0x00, 0x60, 0x84, 0x40, 0xa6, 0x91, 0x00, 0x5d,
	0x00, 0x25, 0xee, 0x94, 0xdd, 0xdd, 0xa4, 0xb0,
	0x02, 0x5c, 0xcc, 0xcc, 0xa4, 0x00, 0x7e, 0x00,
	0x00, 0x7e
};

static const uint8 src2000[] = {
	0x0c, 0x00, 0x4a, 0x00, 0x1e, 0x01, 0x11, 0x03,
	0x04, 0x01, 0x17, 0x94, 0x70, 0xff, 0x03, 0x04,
	0x01, 0x17, 0x9f, 0x03, 0x08, 0x00, 0x15, 0x94,
	0x82, 0x05, 0x11, 0xe3, 0x0c, 0x3f, 0x05, 0x20,
	0x11, 0x11, 0x17, 0x09, 0x08, 0xb4, 0x05, 0x49,
	0x60, 0x11, 0x11, 0x70, 0x01, 0x77, 0x03, 0x08,
	0x00, 0x64, 0x17, 0x7f, 0x00, 0x2c, 0xa8, 0x06,
	0x44, 0x01, 0x62, 0x81, 0x04, 0x64, 0x87, 0x10,
	0xbd, 0x00, 0x70, 0x71, 0x87, 0xc1, 0x07, 0x17,
	0x07, 0x00, 0x00, 0x70, 0x00, 0x11, 0x71, 0x02,
	0x3c, 0x02, 0x1c, 0x11, 0x00, 0x3c, 0xff, 0x83,
	0x02, 0x8e, 0x8c, 0x88, 0x06, 0x60, 0x08, 0x4c,
	0x0f, 0xa2, 0x01, 0xd5, 0xff, 0x01, 0x24, 0x08,
	0x04, 0x02, 0xdd, 0x04, 0xa0, 0x05, 0x0b, 0x09,
	0x20, 0x04, 0x33, 0x05, 0x3f, 0xf8, 0x01, 0x71,
	0x71, 0x01, 0x70, 0x00, 0x80, 0x00, 0x88, 0xac,
	0x0d, 0x70, 0xff, 0x24, 0x38, 0x06, 0xd8, 0x1a,
	0x90, 0x21, 0x6f, 0x00, 0x30, 0x21, 0x03, 0x2c,
	0x53, 0x22, 0x18, 0x7f, 0x1e, 0x01, 0x07, 0x40,
	0x29, 0x86, 0x07, 0xe8, 0x07, 0x07, 0x03, 0x2c,
	0x20, 0x7c, 0x17, 0xf5, 0xa2, 0x11, 0x20, 0x78,
	0x71, 0xba, 0xa2, 0x22, 0x8c, 0x02, 0x75, 0xff,
	0x03, 0xd8, 0x2b, 0x00, 0x25, 0x28, 0x09, 0x40,
	0x02, 0x29, 0x03, 0xb5, 0x01, 0xbc, 0x21, 0xe8,
	0xfb, 0x08, 0x20, 0x02, 0x49, 0x01, 0x01, 0x54,
	0x0d, 0x60, 0x20, 0xf4, 0x02, 0x84, 0x06, 0x04,
	0xfa, 0x77, 0x00, 0x3c, 0x10, 0x05, 0xc1, 0x21,
	0x34, 0x06, 0x73, 0x02, 0x94, 0x0c, 0xa0, 0xff,
	0x0c, 0x20, 0x0d, 0xc0, 0x41, 0x78, 0x41, 0x6e,
	0x33, 0xe8, 0x0c, 0xc0, 0x10, 0x40, 0x0c, 0x14,
	0xff, 0x02, 0xc8, 0x0a, 0xc0, 0x2d, 0x70, 0x2f,
	0x7c, 0x12, 0x20, 0x47, 0xdf, 0x2c, 0x94, 0x46,
	0x7b, 0xff, 0x2b, 0xfd, 0x25, 0xfc, 0x4e, 0x04,
	0x0e, 0x35, 0x2c, 0xe1, 0x29, 0x80, 0x49, 0x55,
	0x06, 0x08, 0xff, 0x20, 0x80, 0x21, 0x78, 0x61,
	0x38, 0x40, 0xc8, 0x62, 0x48, 0x60, 0xa2, 0x23,
	0xac, 0x45, 0x00, 0xff, 0x27, 0x24, 0x22, 0x50,
	0x26, 0xf0, 0x61, 0xb3, 0x0a, 0x1c, 0x06, 0x0c,
	0x01, 0x18, 0x4b, 0x20, 0x9f, 0x69, 0x43, 0x27,
	0xa0, 0x21, 0x53, 0x23, 0xfc, 0x09, 0x02, 0x11,
	0x70, 0x45, 0x3f, 0xff, 0x03, 0x70, 0x25, 0xe0,
	0x01, 0x2c, 0x46, 0x0c, 0x02, 0x80, 0x0b, 0x20,
	0x48, 0x0c, 0x65, 0xa0, 0xff, 0x0a, 0x80, 0x08,
	0xbc, 0x25, 0x50, 0x09, 0x78, 0x08, 0xdc, 0x05,
	0xe0, 0x02, 0xa8, 0x51, 0xfc, 0xff, 0x47, 0xc0,
	0x43, 0xf1, 0x08, 0x04, 0xa2, 0x02, 0x17, 0x06,
	0x60, 0x03, 0x10, 0x41, 0xeb, 0x7f, 0x03, 0xc4,
	0x25, 0x94, 0x73, 0x57, 0x09, 0xe0, 0x62, 0x1a,
	0xa2, 0x40, 0x7c, 0x11, 0xfc, 0x71, 0x71, 0x67,
	0x26, 0x62, 0x16, 0x61, 0xd6, 0x25, 0x7c, 0x60,
	0xbc, 0x02, 0xc0, 0xff, 0x25, 0xa0, 0x44, 0x41,
	0x29, 0xa0, 0x09, 0xdc, 0x48, 0x50, 0x2c, 0x04,
	0x66, 0x70, 0x12, 0x40, 0x59, 0x23, 0x24, 0x77,
	0x00, 0x00, 0x93, 0x10, 0x40, 0x10, 0x67, 0x84,
	0x00, 0xff, 0x02, 0x20, 0x29, 0x80, 0x23, 0xf4,
	0x6f, 0xa0, 0x36, 0x05, 0x2d, 0xa0, 0x11, 0xc0,
	0x0d, 0x18, 0xb7, 0x02, 0x9c, 0x47, 0xe8, 0x20,
	0x35, 0x17, 0x09, 0x04, 0x20, 0x48, 0x10, 0x00,
	0xbb, 0xfe, 0x10, 0x20, 0x38, 0x03, 0x40, 0x40,
	0xfe, 0x06, 0x90, 0x49, 0xec, 0x00, 0x18, 0x64,
	0xaf, 0xfe, 0x11, 0x0a, 0x20, 0x47, 0x00, 0x46,
	0xa0, 0x6a, 0x5c, 0x45, 0x2f, 0x45, 0xc1, 0x21,
	0xc7, 0xff, 0x01, 0xfc, 0x0d, 0x04, 0x45, 0x20,
	0x00, 0x88, 0x02, 0x8c, 0x42, 0x20, 0x01, 0x44,
	0x41, 0x24, 0xff, 0x03, 0x08, 0x66, 0xa0, 0x62,
	0xd4, 0x0c, 0x04, 0x66, 0xa0, 0x41, 0x73, 0x63,
	0x44, 0x45, 0x14, 0xff, 0x1e, 0x01, 0x06, 0xb8,
	0x04, 0x8c, 0x05, 0x6c, 0x1a, 0x30, 0x02, 0xb5,
	0x40, 0xd8, 0x46, 0xe0, 0xff, 0x4b, 0xc0, 0x50,
	0x48, 0x0a, 0x41, 0x6a, 0x88, 0x47, 0x00, 0x66,
	0x51, 0x6d, 0x7c, 0x25, 0x40, 0xff, 0x0d, 0x40,
	0x42, 0xe4, 0x42, 0x4c, 0x44, 0xa2, 0x22, 0x78,
	0x42, 0x44, 0x4e, 0x4c, 0x0a, 0x80, 0xfe, 0x17,
	0x0c, 0x5c, 0x4b, 0xec, 0x6e, 0x08, 0x64, 0xa0,
	0x66, 0x09, 0x54, 0xa0, 0x15, 0x21, 0xef, 0x45,
	0x54, 0x0b, 0x12, 0x22, 0x38, 0x20, 0xd3, 0x71,
	0x01, 0x18, 0x47, 0x20, 0x71, 0x00, 0xbb, 0x2c,
	0x40, 0x40, 0xc8, 0x70, 0x40, 0xbc, 0x4a, 0xcc,
	0x2a, 0xa0, 0x71, 0x14, 0xc0, 0xff, 0x2e, 0x80,
	0x6b, 0x80, 0x12, 0x40, 0x28, 0x18, 0x39, 0x40,
	0x09, 0x22, 0x07, 0x40, 0x33, 0x7f, 0xff, 0x25,
	0x0c, 0x23, 0xf8, 0x48, 0x20, 0x41, 0xdf, 0x61,
	0x34, 0x41, 0xfc, 0x04, 0x0c, 0x40, 0x67, 0xff,
	0x21, 0x25, 0x0b, 0xa0, 0x2d, 0x9c, 0x0d, 0xc0,
	0x09, 0xdc, 0x61, 0xbe, 0x0c, 0xff, 0x41, 0x21,
	0xff, 0x29, 0x3c, 0x21, 0x8c, 0x0b, 0x40, 0x00,
	0x23, 0x20, 0x98, 0x22, 0x7c, 0x21, 0xa8, 0x6c,
	0x4c, 0xff, 0x4f, 0x9c, 0x2b, 0x44, 0x63, 0x50,
	0x42, 0x8c, 0x05, 0xd0, 0x47, 0x40, 0x41, 0x2b,
	0x03, 0x17, 0xff, 0x06, 0x0c, 0x47, 0x37, 0x68,
	0xdf, 0x11, 0x10, 0x0b, 0x35, 0x00, 0x1d, 0x09,
	0x4d, 0x04, 0x5f, 0xbc, 0x71, 0x77, 0x07, 0x11,
	0x6d, 0xb9, 0x61, 0x13, 0x00, 0xce, 0x17, 0x40,
	0x3b, 0x7f, 0x60, 0x26, 0x40, 0x38, 0x60, 0x08,
	0x00, 0xde, 0x42, 0x78, 0x20, 0x19, 0x1f, 0x00
};

static const uint8 srcPlaneA[] = {
	0x10, 0x00, 0xfc, 0x40, 0x00, 0x1e, 0x02, 0x1a,
	0x02, 0x1e, 0x01, 0x1c, 0x01, 0x1e, 0x62, 0x1e,
	0x80, 0xff, 0x1e, 0x01, 0x1e, 0x80, 0x1e, 0x02,
	0x1e, 0x80, 0x1e, 0x01, 0x1e, 0x80, 0x1e, 0x02,
	0x1e, 0x80, 0x87, 0x1e, 0x01, 0x1e, 0x80, 0x0f,
	0x58, 0x20, 0x14, 0x20, 0x15, 0x04, 0x02, 0x78,
	0x16, 0x20, 0x17, 0x11, 0x30, 0x1e, 0x01, 0x1e,
	0x80, 0x1a, 0x80, 0x19, 0xc4, 0x20, 0x1a, 0x04,
	0x02, 0x1b, 0x20, 0x1c, 0x1e, 0x80, 0x1e, 0x01,
	0x03, 0x1e, 0x80, 0x0a, 0x58, 0x20, 0x1d, 0x20,
	0x1e, 0x20, 0x1f, 0x7b, 0xb2, 0x81, 0x21, 0x13,
	0x30, 0x1e, 0x01, 0x1e, 0x80, 0x18, 0x80, 0x22,
	0x10, 0x20, 0x23, 0x20, 0x24, 0xb2, 0x25, 0x20,
	0x26, 0x0f, 0x1e, 0x80, 0x1e, 0x01, 0x19, 0x80,
	0x0d, 0x18, 0x20, 0x27, 0x20, 0x28, 0x10, 0x20,
	0x29, 0x20, 0x2a, 0x92, 0x2b, 0x20, 0x2c, 0xfc,
	0x20, 0x2d, 0x1e, 0x38, 0x1e, 0x01, 0x1e, 0x80,
	0x23, 0xf2, 0xcd, 0x18, 0x20, 0x2e, 0x20, 0x2f,
	0x20, 0x30, 0x20, 0x31, 0x20, 0x32, 0x20, 0x33,
	0x20, 0x34, 0x20, 0x35, 0x20, 0x36, 0x20, 0x37,
	0x1e, 0x38, 0x07, 0x1e, 0x01, 0x1e, 0x80, 0x05,
	0xf8, 0x38, 0x20, 0x39, 0x20, 0x3a, 0x11, 0xb2,
	0x3b, 0x20, 0x3c, 0x66, 0xa6, 0x14, 0x40, 0x15,
	0x79, 0x04, 0x02, 0x16, 0x40, 0x6a, 0x08, 0x1e,
	0x01, 0x1e, 0x80, 0x4a, 0xf0, 0x3d, 0x10, 0x20,
	0x3e, 0x20, 0x3f, 0xb2, 0x40, 0x20, 0x41, 0x41,
	0x06, 0x7e, 0x18, 0x40, 0x19, 0x40, 0x1a, 0x04,
	0x02, 0x1b, 0x1e, 0x40, 0x6a, 0x08, 0x1e, 0x01,
	0x1e, 0x80, 0x0a, 0x80, 0x42, 0x20, 0x43, 0x11,
	0x04, 0x02, 0x44, 0x20, 0x45, 0x06, 0x80, 0x1d,
	0x40, 0x1e, 0xe4, 0x40, 0x1f, 0xb2, 0x20, 0x40,
	0x6c, 0x08, 0x1e, 0x01, 0x1e, 0x80, 0x41, 0x48,
	0xf0, 0x46, 0x20, 0x47, 0x20, 0x48, 0x04, 0x02,
	0x49, 0x41, 0x68, 0x24, 0x22, 0x40, 0x23, 0x40,
	0x24, 0xb2, 0x25, 0x1e, 0x40, 0x6c, 0x08, 0x1e,
	0x01, 0x1e, 0x80, 0x08, 0x80, 0x4a, 0x20, 0x4b,
	0x14, 0x20, 0x4c, 0x04, 0x02, 0x4d, 0x04, 0x7c,
	0x27, 0x40, 0x28, 0x10, 0x40, 0x29, 0x40, 0x2a,
	0x92, 0x2b, 0x40, 0x2c, 0xfe, 0x40, 0x66, 0x08,
	0x1e, 0x80, 0x1e, 0x01, 0x7b, 0x80, 0x20, 0xf4,
	0xca, 0x2e, 0x40, 0x2f, 0x40, 0x30, 0x40, 0x31,
	0x40, 0x32, 0x40, 0x33, 0x40, 0x34, 0x40, 0x35,
	0x40, 0x36, 0x40, 0x68, 0x08, 0x0f, 0x1e, 0x80,
	0x1e, 0x01, 0x2b, 0x00, 0x0d, 0x50, 0x40, 0x38,
	0x40, 0x39, 0xe4, 0x40, 0x3a, 0xb2, 0x3b, 0x40,
	0x60, 0x08, 0x0d, 0x28, 0x1e, 0x80, 0x03, 0x1e,
	0x01, 0x19, 0x80, 0x40, 0x3d, 0x40, 0x3e, 0x40,
	0x3f, 0x7f, 0xb2, 0x81, 0x62, 0x08, 0x1e, 0x80,
	0x1e, 0x01, 0x1e, 0x80, 0x09, 0x80, 0x42, 0xe4,
	0x40, 0x43, 0x04, 0x02, 0x44, 0x40, 0x62, 0x08,
	0x1e, 0x80, 0x1e, 0x01, 0x03, 0x1e, 0x80, 0x06,
	0x50, 0x40, 0x46, 0x40, 0x47, 0x40, 0x48, 0x3f,
	0x04, 0x02, 0x64, 0x08, 0x1e, 0x80, 0x1e, 0x01,
	0x57, 0x80, 0x0e, 0x5e, 0x4a, 0x40, 0xe8, 0x4b,
	0x40, 0x4c, 0x04, 0x02, 0x4d, 0x15, 0x7a, 0x1e,
	0x80, 0x1e, 0x01, 0xff, 0x19, 0xd8, 0x1e, 0x02,
	0x1e, 0x80, 0x1e, 0x01, 0x33, 0x80, 0xd9, 0x51,
	0x00, 0x52, 0x00, 0x53, 0x00, 0x54, 0x00, 0x55,
	0x00, 0x56, 0x00, 0x57, 0x00, 0x58, 0x00, 0x59,
	0x00, 0x5a, 0x00, 0x5b, 0x00, 0x5c, 0x00, 0x5d,
	0x00, 0x5e, 0x00, 0x5f, 0x00, 0x4e, 0x00, 0x4f,
	0x1e, 0x80, 0x1e, 0x01, 0xff, 0x57, 0x80, 0xde,
	0x00, 0x60, 0x00, 0x61, 0x00, 0x62, 0x00, 0x63,
	0x00, 0x64, 0x00, 0x65, 0x00, 0x66, 0x00, 0x67,
	0x00, 0x68, 0x00, 0x69, 0x00, 0x6a, 0x00, 0x6b,
	0x00, 0x6c, 0x00, 0x6d, 0x00, 0x6e, 0x00, 0x6f,
	0x00, 0x90, 0x00, 0x91, 0x00, 0x92, 0x1e, 0x80,
	0x1e, 0x01, 0x16, 0x80, 0xdd, 0x70, 0x00, 0x71,
	0x00, 0x72, 0x00, 0x73, 0x00, 0x74, 0x00, 0x75,
	0x00, 0x76, 0x00, 0x77, 0x00, 0x78, 0x00, 0x79,
	0x00, 0x7a, 0x00, 0x7b, 0x00, 0x7c, 0x00, 0x7d,
	0x00, 0x7e, 0x00, 0x7f, 0x00, 0x50, 0x00, 0x93,
	0x00, 0x94, 0x1e, 0x78, 0x1e, 0x01, 0xff, 0x16,
	0x80, 0xc5, 0x80, 0x00, 0x81, 0x00, 0x82, 0x00,
	0x83, 0x00, 0x84, 0x00, 0x85, 0x00, 0x86, 0x9e,
	0xcd, 0x88, 0x00, 0x89, 0x00, 0x8a, 0x00, 0x8b,
	0x00, 0x8c, 0x00, 0x8d, 0x00, 0x8e, 0x00, 0x8f,
	0x00, 0x87, 0x00, 0x95, 0x00, 0x96, 0x1e, 0x80,
	0x1e, 0x01, 0x5e, 0x80, 0x1e, 0x02, 0xff, 0x1e,
	0x01, 0x1e, 0x01, 0x1e, 0x80, 0x1e, 0x80, 0x1e,
	0x01, 0x1e, 0x01, 0x1e, 0x98, 0x1e, 0x28, 0xff,
	0x1e, 0x01, 0x1e, 0x01, 0x1e, 0x80, 0x1e, 0x01,
	0x1e, 0x01, 0x1e, 0x01, 0x1e, 0x80, 0x1e, 0x01,
	0x7f, 0x1e, 0x01, 0x1e, 0x01, 0x1e, 0x80, 0x1e,
	0x01, 0x1e, 0x01, 0x50, 0x80, 0x1f
};

static const uint8 srcPlaneB[] = {
	0x10, 0x00, 0xfc, 0x00, 0x01, 0x1e, 0x02, 0x1b,
	0x02, 0x1e, 0x01, 0x1c, 0x01, 0x1e, 0x62, 0x1b,
	0x02, 0xbc, 0x60, 0x02, 0x1e, 0x02, 0x1a, 0x02,
	0x1e, 0x62, 0x1d, 0x80, 0x03, 0x1e, 0x02, 0xff,
	0x1a, 0x02, 0x1e, 0x62, 0x1e, 0x02, 0x1e, 0x02,
	0x1e, 0x02, 0x1e, 0x02, 0x1e, 0x02, 0x1e, 0x02,
	0xff, 0x1e, 0x02, 0x1e, 0x02, 0x1e, 0x02, 0x1e,
	0x02, 0x1e, 0x02, 0x1e, 0x02, 0x1e, 0x02, 0x1e,
	0x02, 0xff, 0x1e, 0x02, 0x1e, 0x02, 0x1e, 0x02,
	0x1e, 0x02, 0x1e, 0x02, 0x1e, 0x02, 0x1e, 0x02,
	0x1e, 0x02, 0xff, 0x1e, 0x02, 0x1e, 0x02, 0x1e,
	0x02, 0x1e, 0x02, 0x1e, 0x02, 0x1e, 0x02, 0x1e,
	0x02, 0x1e, 0x02, 0xff, 0x1e, 0x02, 0x1e, 0x02,
	0x1e, 0x02, 0x1e, 0x02, 0x1e, 0x02, 0x1e, 0x02,
	0x1e, 0x02, 0x1e, 0x02, 0xff, 0x1e, 0x02, 0x1e,
	0x02, 0x1e, 0x02, 0x1e, 0x02, 0x1e, 0x02, 0x1e,
	0x02, 0x1e, 0x02, 0x1e, 0x02, 0xff, 0x1e, 0x02,
	0x1e, 0x02, 0x1e, 0x02, 0x1e, 0x02, 0x1e, 0x02,
	0x1e, 0x02, 0x1e, 0x02, 0x1e, 0x02, 0xff, 0x1e,
	0x02, 0x1e, 0x02, 0x1e, 0x02, 0x1e, 0x02, 0x1e,
	0x02, 0x1e, 0x02, 0x1e, 0x02, 0x1e, 0x02, 0xff,
	0x1e, 0x02, 0x1e, 0x02, 0x1e, 0x02, 0x1e, 0x02,
	0x1e, 0x02, 0x1e, 0x02, 0x1e, 0x02, 0x1e, 0x02,
	0xff, 0x1e, 0x02, 0x1e, 0x02, 0x1e, 0x02, 0x1e,
	0x02, 0x1e, 0x02, 0x1e, 0x02, 0x1e, 0x02, 0x1e,
	0x02, 0xff, 0x1e, 0x02, 0x1e, 0x02, 0x1e, 0x02,
	0x1e, 0x02, 0x1e, 0x02, 0x1e, 0x02, 0x1e, 0x02,
	0x1e, 0x02, 0xff, 0x1e, 0x02, 0x1e, 0x02, 0x1e,
	0x02, 0x1e, 0x02, 0x1e, 0x02, 0x1e, 0x02, 0x1e,
	0x02, 0x1e, 0x02, 0xff, 0x1e, 0x02, 0x1e, 0x02,
	0x1e, 0x02, 0x1e, 0x02, 0x1e, 0x02, 0x1e, 0x02,
	0x1e, 0x02, 0x1e, 0x02, 0xff, 0x1e, 0x02, 0x1e,
	0x02, 0x1e, 0x02, 0x1e, 0x02, 0x1e, 0x02, 0x1e,
	0x02, 0x1e, 0x02, 0x1e, 0x02, 0x07, 0x1e, 0x02,
	0x0d, 0x02, 0x1f, 0x00
};

void Renderer_SCD::reconfigPlanes() {
	if (_modeChange == 0xFF)
		_mode = 1;
	else if (_modeChange)
		_mode = 2;

	static const uint16 dimCfgData[3][2] = {
		{512, 512},
		{256, 512},
		{512, 256}
	};

	static const uint16 memCfgData[3][5] = {
		{0xE000, 0xC000, 0xB000, 0xBE00, 0xB800},
		{0xE000, 0xC000, 0xF000, 0xFE00, 0xF800},
		{0xE000, 0xC000, 0xF000, 0xFE00, 0xF800}
	};

	_sr->setupPlaneAB(dimCfgData[_mode][0], dimCfgData[_mode][1]);

	const uint16 *in = memCfgData[_mode];
	_sr->setPlaneTableLocation(Graphics::SegaRenderer::kPlaneA, *in++);
	_sr->setPlaneTableLocation(Graphics::SegaRenderer::kPlaneB, *in++);
	_sr->setPlaneTableLocation(Graphics::SegaRenderer::kWindowPlane, *in++);
	_sr->setSpriteTableLocation(*in++);
	_sr->setHScrollTableLocation(*in);

	in = memCfgData[_mode];
	_sr->memsetVRAM(*in++, 0, 0x1000);
	_sr->memsetVRAM(*in++, 0, 0x1000);
	in += 2;
	_sr->memsetVRAM(*in, 0, 0x200);
	_sr->memsetVRAM(0, 0, _mode ? 0xC000 : 0xB000);

	static const uint8 data[] = {
		0x33, 0x2e, 0x21, 0x34, 0x23, 0x28, 0x25, 0x32,
		0x00, 0x34, 0x2d, 0x00, 0x29, 0x33, 0x21, 0x00,
		0x34, 0x32, 0x21, 0x24, 0x25, 0x2d, 0x21, 0x32,
		0x2b, 0x00, 0x2f, 0x26, 0x00, 0x2b, 0x2f, 0x2e,
		0x21, 0x2d, 0x29, 0x00, 0x23, 0x2f, 0x0e, 0x0c,
		0x2c, 0x34, 0x24, 0x0e, 0x34, 0x2d, 0x00, 0x21,
		0x2e, 0x24, 0x00, 0x5f, 0x00, 0x11, 0x19, 0x19,
		0x14, 0x00, 0x2b, 0x2f, 0x2e, 0x21, 0x2d, 0x29,
		0x00, 0x23, 0x2f, 0x0e, 0x0c, 0x2c, 0x34, 0x24,
		0x0e, 0x00, 0x2c, 0x29, 0x23, 0x25, 0x2e, 0x33,
		0x25, 0x24, 0x00, 0x22, 0x39, 0x00, 0x33, 0x25,
		0x27, 0x21, 0x00, 0x25, 0x2e, 0x34, 0x25, 0x32,
		0x30, 0x32, 0x29, 0x33, 0x25, 0x33, 0x0c, 0x2c,
		0x34, 0x24, 0x0e
	};

	uint16 *d = new uint16[ARRAYSIZE(data)];
	for (int i = 0; i < ARRAYSIZE(data); ++i)
		d[i] = TO_BE_16(data[i] | 0x100);

	_sr->loadToVRAM(d, 22, 0xE294);
	_sr->loadToVRAM(&d[12], 4, 0xE39C);
	_sr->loadToVRAM(&d[14], 60, 0xE482);
	_sr->loadToVRAM(&d[44], 58, 0xE704);
	_sr->loadToVRAM(&d[74], 22, 0xEA94);
	_sr->loadToVRAM(&d[86], 42, 0xEB8C);
	
	delete[] d;

	uint32 len = Util::decodeSCDData(src0000 + 2, _tempBuffer);
	_sr->loadToVRAM(_tempBuffer, len, 0);
	len = Util::decodeSCDData(src2000 + 2, _tempBuffer);
	_sr->loadToVRAM(_tempBuffer, len, 0x2000);
	len = Util::decodeSCDData(srcPlaneA + 2, _tempBuffer);
	_sr->loadToVRAM(_tempBuffer, len, 0xE000);
	len = Util::decodeSCDData(srcPlaneB + 2, _tempBuffer);
	_sr->loadToVRAM(_tempBuffer, len, 0xC000);
	
	_modeChange = 0;
}

void Renderer_SCD::updateScrollState() {
	if (!_scroll->nextFrame())
		return;

	const ScrollManager::ScrollState &s = _scroll->getState();

	if (s.hInt.needUpdate) {
		_sr->hINT_enable(s.hInt.enable);
		_sr->hINT_setCounter(s.hInt.counter);
		if (!s.hInt.enable)
			_sr->enableDisplay(true);
	}

	if (!s.disableVScroll) {
		_sr->writeUint16VSRAM(0, TO_BE_16(s.offsets[ScrollManager::kVertA] & 0x3FF));
		_sr->writeUint16VSRAM(2, TO_BE_16(s.offsets[ScrollManager::kVertB] & 0x3FF));
	}

	if (s.lineScrollMode) {
		for (int i = 0; i < s.hScrollTableNumEntries; ++i)
			_sr->writeUint16VRAM(0xF822 + i * 4, TO_BE_16(s.hScrollTable[i] & 0x3FF));
	} else {
		uint16 addr = _mode ? 0xF800 : 0xB800;
		_sr->writeUint16VRAM(addr, TO_BE_16(s.offsets[ScrollManager::kHorzA] & 0x3FF));
		_sr->writeUint16VRAM(addr + 2, TO_BE_16(s.offsets[ScrollManager::kHorzB] & 0x3FF));
	}
}

void Renderer_SCD::drawSprite(AnimObject &a) {
	const uint16 *in = a.spriteData;
	uint16 num = FROM_BE_16(*in++);
	uint16 *d = _spriteBuffer;
	memset(d, 0, 4 * sizeof(uint16));
	int nxt = 1;

	uint32 curY = a.posY + 0x800000;
	uint32 curX = a.posX + 0x800000;

	if (a.drawFlags & 4) {
		const ScrollManager::ScrollState &s = _scroll->getState();
		curX += s.offsets[ScrollManager::kHorzA];
		curY += s.offsets[ScrollManager::kVertA];
	}

	if (a.drawFlags & 8) {
		const ScrollManager::ScrollState &s = _scroll->getState();
		curX += s.offsets[ScrollManager::kHorzB];
		curY += s.offsets[ScrollManager::kVertB];
	}

	uint16 flip = (a.drawFlags & 3) << 11;
	uint16 p = ((a.f18 & 4) << 13) | ((a.f18 & 0xF8) >> 3);

	for (int i = 0; i < num && nxt < 65; ++i) {
		uint16 origY = FROM_BE_16(*in++);
		uint16 hw = FROM_BE_16(*in++);

		if (a.drawFlags & 2)
			origY = -origY - (((hw >> 5) & 0x18) + 8);

		uint16 tl = FROM_BE_16(*in++);
		uint16 origX = FROM_BE_16(*in++);

		if (a.drawFlags & 1)
			origX = -origX - (((hw >> 7) & 0x18) + 8);

		tl = (tl | p) ^ flip;
		if (a.f16 & 0x80) {
			uint16 v = (a.f16 & 3) << 13;
			tl = (tl & 0x9FFF) | v;
		}

		*d++ = TO_BE_16(origY + (curY >> 16));
		*d++ = TO_BE_16(hw + (nxt++));
		*d++ = TO_BE_16(tl);
		*d++ = TO_BE_16(origX + (curX >> 16));
	}

	if (d - 3 > _spriteBuffer)
		*(reinterpret_cast<uint8*>(d) - 5) = 0;

	_sr->loadToVRAM(_spriteBuffer, (d - _spriteBuffer) * sizeof(uint16), 0xFE00);
}

void Renderer_SCD::updateAnim32Spec(AnimObject &a) {

}

bool Renderer_SCD::reachedAudioTimeStamp(AnimObject &a) const {
	return _gfxState.getAudioSync() >= a.timeStamp;
}

void Renderer_SCD::runAnimScript(AnimObject &a) {
	if (--a.frameDelay > 0) {
		if (a.scriptData[a.frame << 2] != 0x97)
			a.controlFlags &= ~GraphicsEngine::kAnimHide;
		return;
	}

	int incr = (a.f4f == 0) ? 1 : 0;

	while (incr != -1) {
		a.frame += incr;
		a.controlFlags &= ~GraphicsEngine::kAnimHide;
		const uint8 *in = a.scriptData() + (a.frame << 2);
		uint8 opcode = *in++;
		if (opcode & 0x80) {
			opcode -= 0x80;
			debug("%s(): anim: %d, opcode %d", __FUNCTION__, &a - _animations, opcode);
			assert(opcode < _animProcs.size());
			if (_animProcs[opcode]->isValid())
				incr = (*_animProcs[opcode])(a, in);
			else
				error("%s(): Invalid opcode %d", __FUNCTION__, opcode);
		} else {
			incr = anim_updateFrameDelay(a, in);
		}
	}
}

#define ANM(x) &Renderer_SCD::anim_##x
void Renderer_SCD::makeAnimFunctions() {
	typedef int (Renderer_SCD::*AnimFunc)(AnimObject&, const uint8*);
	static const AnimFunc funcTbl[] = {
		ANM(remove),
		ANM(setFrame),
		ANM(seqSetFrame),
		ANM(rndSeqSetFrame),
		ANM(setX),
		ANM(setY),
		ANM(06),
		ANM(07),
		ANM(palEvent),
		ANM(palReset),
		ANM(copyCmds),
		ANM(11),
		ANM(12),
		ANM(13),
		ANM(14),
		ANM(15),
		ANM(pause),
		ANM(pause),
		ANM(pause),
		ANM(pause),
		ANM(resumeAndUnsyncOther),
		ANM(removeOther),
		ANM(pauseAndHideOther),
		ANM(hide),
		ANM(24),
		ANM(audioSync),
		ANM(audioSync),
		ANM(27),
		ANM(28),
		ANM(29),
		ANM(30),
		ANM(31),
		ANM(setDrawFlags),
		ANM(setDrawFlags),
		ANM(34),
		ANM(35),
		ANM(36),
		ANM(37),
		ANM(38),
		ANM(39),
		ANM(40),
		ANM(41),
		ANM(42),
		ANM(43),
		ANM(allowFrameDrop),
		ANM(45),
		ANM(46),
		ANM(47)
	};

	for (uint i = 0; i < ARRAYSIZE(funcTbl); ++i) \
		_animProcs.push_back(new GfxAnimFunc(this, funcTbl[i]));
}
#undef ANM

uint16 animRand(uint16 a, uint16 b) {
	return ((b * Util::rngMakeNumber()) >> 16) + a;
}

int Renderer_SCD::anim_remove(AnimObject &a, const uint8 *data) {
	a.clear();
	return -1;
}

int Renderer_SCD::anim_setFrame(AnimObject &a, const uint8 *data) {
	a.frame = *data;
	return 0;
}

int Renderer_SCD::anim_seqSetFrame(AnimObject &a, const uint8 *data) {
	if (a.frameSeqCounter == *data++) {
		a.frameSeqCounter = 0;
		return 1;
	}
	++a.frameSeqCounter;
	a.frame = *++data;
	return 0;
}

int Renderer_SCD::anim_rndSeqSetFrame(AnimObject &a, const uint8 *data) {
	if (a.frameSeqCounter == 0)
		a.frameSeqCounter = animRand(2, (uint16)data[1] - data[0]) & 0xFF;
	if (a.frameSeqCounter == data[1]) {
		a.frameSeqCounter = 0;
		return 1;
	}
	++a.frameSeqCounter;
	a.frame = data[2];
	return 0;
}

int Renderer_SCD::anim_setX(AnimObject &a, const uint8 *data) {
	uint16 xdiff = READ_BE_UINT16(data + 1) - (a.posX >> 16);
	a.frameDelay = -1;
	anim_setGroupParameter(a, 0, xdiff);
	return 1;
}

int Renderer_SCD::anim_setY(AnimObject &a, const uint8 *data) {
	uint16 ydiff = READ_BE_UINT16(data + 1) - (a.posY >> 16);
	a.frameDelay = -1;
	anim_setGroupParameter(a, 1, ydiff);
	return 1;
}

int Renderer_SCD::anim_06(AnimObject &a, const uint8 *data) {
	a.speedXa = (READ_BE_UINT16(data + 1) << 16) | (*data << 8);
	anim_setGroupParameter(a, 2);
	return 1;
}

int Renderer_SCD::anim_07(AnimObject &a, const uint8 *data) {
	a.speedYa = (READ_BE_UINT16(data + 1) << 16) | (*data << 8);
	anim_setGroupParameter(a, 3);
	return 1;
}

int Renderer_SCD::anim_palEvent(AnimObject &a, const uint8 *data) {
	if (_gfxState.getVar(2))
		return 1;
	ResourcePointer r = a.scriptData + READ_BE_INT16(data + 1);
	_pal->enqueueEvent(r);
	_gfxState.setVar(3, 1);
	return 1;
}

int Renderer_SCD::anim_palReset(AnimObject &a, const uint8 *data) {
	_pal->clearEvents();
	return 1;
}

int Renderer_SCD::anim_copyCmds(AnimObject &a, const uint8 *data) {
	ResourcePointer r = a.scriptData + READ_BE_INT16(data + 1);
	return enqueueCopyCommands(r) ? 1 : -1;
}

int Renderer_SCD::anim_11(AnimObject &a, const uint8 *data) {
	return 1;
}

int Renderer_SCD::anim_12(AnimObject &a, const uint8 *data) {
	_scroll->doCommand(1);
	_scroll->setSingleStep(*data ? ScrollManager::kHorzB : ScrollManager::kHorzA, READ_BE_INT16(data + 1));
	return 1;
}

int Renderer_SCD::anim_13(AnimObject &a, const uint8 *data) {
	_scroll->doCommand(1);
	_scroll->setSingleStep(*data ? ScrollManager::kVertB : ScrollManager::kVertA, READ_BE_INT16(data + 1));
	return 1;
}

int Renderer_SCD::anim_14(AnimObject &a, const uint8 *data) {
	_scroll->doCommand(2);
	_scroll->setDirectionAndSpeed(*data ? ScrollManager::kHorzB : ScrollManager::kHorzA, READ_BE_INT16(data + 1));
	return 1;
}

int Renderer_SCD::anim_15(AnimObject &a, const uint8 *data) {
	_scroll->doCommand(2);
	_scroll->setDirectionAndSpeed(*data ? ScrollManager::kVertB : ScrollManager::kVertA, READ_BE_INT16(data + 1));
	return 1;
}

int Renderer_SCD::anim_pause(AnimObject &a, const uint8 *data) {
	anim_setGroupParameter(a, 5);
	return 1;
}

int Renderer_SCD::anim_resumeAndUnsyncOther(AnimObject &a, const uint8 *data) {
	assert(*data < 64);
	anim_setGroupParameter(_animations[*data], 4);
	return 1;
}

int Renderer_SCD::anim_removeOther(AnimObject &a, const uint8 *data) {
	assert(*data < 64);
	_animations[*data].clear();
	return 1;
}

int Renderer_SCD::anim_pauseAndHideOther(AnimObject &a, const uint8 *data) {
	assert(*data < 64);
	_animations[*data].controlFlags = GraphicsEngine::kAnimPause | GraphicsEngine::kAnimHide;
	return 1;
}

int Renderer_SCD::anim_hide(AnimObject &a, const uint8 *data) {
	a.controlFlags |= GraphicsEngine::kAnimHide;
	return anim_updateFrameDelay(a, data);
}

int Renderer_SCD::anim_24(AnimObject &a, const uint8 *data) {
	return 1;
}

int Renderer_SCD::anim_audioSync(AnimObject &a, const uint8 *data) {
	a.timeStamp = data[0] << 24 | data[1] << 16 | data[2] << 8;
	a.controlFlags |= GraphicsEngine::kAnimAudioSync;
	return 1;
}

int Renderer_SCD::anim_27(AnimObject &a, const uint8 *data) {
	return 1;
}

int Renderer_SCD::anim_28(AnimObject &a, const uint8 *data) {
	return 1;
}

int Renderer_SCD::anim_29(AnimObject &a, const uint8 *data) {
	return 1;
}

int Renderer_SCD::anim_30(AnimObject &a, const uint8 *data) {
	return 1;
}

int Renderer_SCD::anim_31(AnimObject &a, const uint8 *data) {
	return 1;
}

int Renderer_SCD::anim_setDrawFlags(AnimObject &a, const uint8 *data) {
	a.drawFlags = READ_BE_UINT16(data + 1);
	return 1;
}

int Renderer_SCD::anim_34(AnimObject &a, const uint8 *data) {
	a.f4f = 0;
	if (_gfxState.getVar(8) == 0)
		return 1;
	a.f4f = 1;
	return -1;
}

int Renderer_SCD::anim_35(AnimObject &a, const uint8 *data) {
	_gfxState.setVar(5, 1);
	return 1;
}

int Renderer_SCD::anim_36(AnimObject &a, const uint8 *data) {
	_gfxState.setFlag(1, 0);
	return 1;
}

int Renderer_SCD::anim_37(AnimObject &a, const uint8 *data) {
	static const uint8 cmd[] = { 0x25, 0x00 };
	ResourcePointer r(data, 0);
	enqueueCopyCommands(r);
	return 1;
}

int Renderer_SCD::anim_38(AnimObject &a, const uint8 *data) {
	return 1;
}

int Renderer_SCD::anim_39(AnimObject &a, const uint8 *data) {
	return 1;
}

int Renderer_SCD::anim_40(AnimObject &a, const uint8 *data) {
	//gfxDoCommand_D0(*data);
	return 1;
}

int Renderer_SCD::anim_41(AnimObject &a, const uint8 *data) {
	return 1;
	//return -1;
}

int Renderer_SCD::anim_42(AnimObject &a, const uint8 *data) {
	return 1;
}

int Renderer_SCD::anim_43(AnimObject &a, const uint8 *data) {
	return 1;
}

int Renderer_SCD::anim_allowFrameDrop(AnimObject &a, const uint8 *data) {
	a.allowFrameDrop = 1;
	return 1;
}

int Renderer_SCD::anim_45(AnimObject &a, const uint8 *data) {
	return 1;
}

int Renderer_SCD::anim_46(AnimObject &a, const uint8 *data) {
	_gfxState.setFlag(1, 1);
	return 1;
}

int Renderer_SCD::anim_47(AnimObject &a, const uint8 *data) {
	a.f1c = *data;
	return 1;
}

int Renderer_SCD::anim_updateFrameDelay(AnimObject &a, const uint8 *data) {
	if (*data++) {
		uint16 v1 = *data++;
		uint16 v2 = *data - v1;
		a.frameDelay = animRand(v1, v2);
	} else {
		a.frameDelay = READ_BE_INT16(data);
	}
	debug("%s(): anim: %d, setting delay %d", __FUNCTION__,  &a - _animations, a.frameDelay);
	return -1;
}

void Renderer_SCD::anim_setGroupParameter(AnimObject &a, int para, uint16 val, bool recursive) {
	AnimObject *ta = &a;
	for (int n = ta->children; n || !recursive; n = recursive ? ta->next : 0) {
		if (recursive)
			ta = &_animations[n];
		switch (para) {
		case 0:
			ta->posX += (val << 16);
			break;
		case 1:
			ta->posY += (val << 16);
			break;
		case 2:
			a.speedX = a.speedXa;
			if (ta->parent)
				a.speedX += _animations[ta->parent].speedX;
			break;
		case 3:
			a.speedY = a.speedYa;
			if (ta->parent)
				a.speedY += _animations[ta->parent].speedY;
			break;
		case 4:
			ta->controlFlags &= GraphicsEngine::kAnimHide;
			break;
		case 5:
			ta->controlFlags |= GraphicsEngine::kAnimPause;
			break;
		case 6:
			ta->controlFlags = GraphicsEngine::kAnimPause | GraphicsEngine::kAnimHide;
			break;
		default:
			error("%s(): unhandled para %d", __FUNCTION__, para);
			break;

		}
		recursive = true;
		anim_setGroupParameter(*ta, para, val, true);
	}
}

Renderer *Renderer::createSegaRenderer(const Graphics::PixelFormat *pxf, GraphicsEngine::GfxState &state, Palette *pal, ScrollManager *scr) {
	return new Renderer_SCD(pxf, state, pal, scr);
}

} // End of namespace Snatcher
